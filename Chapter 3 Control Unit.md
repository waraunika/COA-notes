# 3.1 Control Memory
- The function of the CU in a digital computer is to initiate sequences of micro-operations.
- When the control signals are generated by hardware using conventional logic design techniques, the control unit is said to be hardwired.
- Micro-programming is an alternative for designing the control unit of a digital computer
	- The principle of micro-programming is an elegant and systematic method for controlling the micro-operation sequences in a digital computer.
- In a bus-organised systems, the control signals that specify micro-operations are groups of bits that select the paths in multiplexers, decoders, and arithmetic logic units.
- A control unit whose binary control variables are stored in memory is called a micro-programmed control unit.
- A memory that is part of a control unit is referred to as a control memory.
	- Each word in control memory contains within it, a micro-program.
	- A sequence of micro-instructions constitutes a micro-program.
	- Can be either read-only memory (ROM) or writable control memory (dynamic micro-programming)
- A computer that employs a micro-programmed control unit will have two separate memories:
	- A main memory
	- A control memory
- The general configuration of a micro-programmed control unit is demonstrated in the block diagram:
  ![Micro-programmed Control Organisation][microprogrammed_control_org.png]
	- The control memory is assumed to be a ROM, within which all control information is permanently stored
	- The Control Address Register specifies the address of the micro-instruction.
	- The Control Data Register holds the micro-instruction  read from the memory.
- Thus, a micro-instruction contains bits for initiating micro-operations in the data processor part and bits that determine the address sequence for the control memory.
# 3.2 Addressing Sequencing
- **Address Sequencing is the process of determining the address of the next micro-instruction to be executed in the control memory, based on the current micro-instruction, status conditions, and control logic**
- Micro-instructions are stored in control memory in groups, with each group specifying a routine.
- Each computer instruction has its own micro-program routine memory to generate the micro-operations that execute the instruction.
- Block diagram of a control memory and the associated hardware needed for selecting the next micro-instruction address.
  ![Selection of address for control memory][selection_of_address.png]
- The micro-instruction in control memory contains
	- a set of bits to initiate micro-operations in computer registers
	- other bits to specify the method by which the next address is obtained.
### 3.2.1 Sequencing Logic in MP-CU
When the system is powered on, the Control Address Register (CAR) is loaded with the address of the first micro-instruction (usually the start of the fetch Routine).
1. Fetching the Micro-instruction
	- The address in the CAR is sent to the control memory.
	- The micro-instruction stored at that address is fetched and loaded into the Control Data Register (CDR) or Control Register (CR).
2. Executing the Micro-instruction
	- The control signals specified by the micro-instruction are generated and sent to various parts of the CPU.
	- These signals perform operations like reading from memory, loading registers, etc.
3. Sequencing the next micro-instruction:
	- The sequencing logic determines the address of the next micro-instruction to execute.
	- This can happen in several ways:
		- Incrementing the CAR (for sequential execution)
		- Branching to another address (for jumps or subroutine calls)
		- Mapping - using part of the opcode from the IR to determine the start address of the routine that handles that instruction.
4. Mapping and subroutines
	- The mapping process converts the operation code (opcode) bits of an instruction into the starting address of its corresponding micro-program in control memory.
	- Subroutines can be called during execution; return addresses are stored in temporary storage (like a register stack).
5. Completion and Return to Fetch:
	- After the micro-program for an instruction completes, the sequencing logic branches back to the starting address of the fetch routine to fetch the next instruction.
### 3.2.2 AS Capabilities Requirements
- When a micro-instruction is executed, the sequencing logic must determine the address of the next micro-instruction to fetch.
- This requires several address sequencing capabilities, allowing flexible control flow in micro-program execution

1. Incrementing the CAR:
	- The most basic capability
	- The CAR is incremented by one to fetch the next micro-instruction in sequence.
	- Used for straight-line execution (normal, step by step flow).
2. Branching to a New Address
	- Allows the control unit to jump to a specific address in control memory.
	- Useful for:
		- Conditional control (based on status bits or flags)
		- Handling different instruction types
	- The next address comes directly from the address field of the current micro-instruction
3. Conditional Branching
	- The next address may depend on the status bits or condition flags in the processor (like Zero, Carry, Overflow)
	- Enables decision-making within micro-programs. eg:
		- If condition = true -> branch to one address
		- Else -> continue sequentially
4. Mapping from IR
	- Used when decoding an instruction from the main program
	- The opcode bits in the IR are used to generate the starting address of the corresponding micro-program.
	- This process is called mapping or micro-instruction mapping
5. Subroutine Call and Return
	- Some micro-programs are common to many instructions (e.g., fetch, indirect, interrupt service)
	- The control unit can branch a subroutine and later return to the point of call.
	- Requires temporary storage (eg: a register stack) to hold the return address.
6. External or Interrupt Control
	- Allows branching to specific control memory addresses when external signals or interrupt requests occur.
	- Provides flexibility for asynchronous events.
# 3.3 Computer Configuration
- Once the configuration of a computer and its micro-programmed control unit is established, the designer's task is to generate the micro-code for the control memory.
- This microcode generation is called micro-programming.
- The block diagram of the computer is shown in fig:
  ![Computer Hardware Configuration][computer_hardware_configuration.png]
- Two memory units
	- A main memory for storing instructions and data
	- A control memory for storing the micro-program
- Four registers are associated with the processor unit
	- Program counter PC, address register AR, data register DR, accumulator register AC
- The control unit has a control address register CAR and a subroutine register SBR.
- The control memory and its register are organised as micro-programmed control unit.
- The transfer of information among the registers in the processor is done through multiplexers rather than a common bus.
# 3.4 Micro-instruction Format
## 3.4.1 Computer Instruction Format
- The computer instruction format is depicted in fig:
  ![Computer Instruction Format | 300][computer_instruction_format.png]
- It consists of three field:
	- A 1-bit field for indirect addressing symbolised by I
	- A 4-bit operation code (opcode)
	- An 11-bit address field
- The fig lists four of the 16 possible memory-reference instructions.
- ![Four Computer Instructions][example_IF.png]
## 3.4.2 Micro-instruction Format
- The micro-instruction format for the control memory is shown in:
  ![Microinstruction Format | 400][instruction_format.png]
- The 20 bits of the micro-instruction are divided into four functional parts
	- The three fields F1, F2 and F3 specify micro-operations for the computer.
	- The CD field selects the type of branch.
	- The BR field specifies the type of branch.
	- The AD field contains a branch address.
#### 3.4.2.1 Micro-operations
- The three bits in each field are encoded to specify seven distinct micro-operations as listed below:
- F1:
  ![F1 Microoperations | 500][f1.png]
- F1:
  ![F1 Microoperations | 500][f2.png]
- F3:
  ![F1 Microoperations | 500][f3.png]
- CD:
  ![F1 Microoperations | 600][CD.png]
- BR:
  ![F1 Microoperations | 600][BR.png]
- No more than three micro-operations can be chosen for a micro-instruction, one from each field.
- If fewer than three micro-operations are used, one or more of the fields will use the binary code 000 for no operation.
- important to realise: Two or more conflicting micro-operations can not be specified simultaneously. eg: 010 001 000
- Each micro operations is defined with a register transfer statement and is assigned a symbol for use in a symbolic micro-program.
### 3.4.2.2 Address Sequencing for next address
- Main 4 mechanisms:
	- incrementing, branching, subroutines and mapping
- The Next Address Generator (NAG), also called Sequencer, is the main component for address sequencing
- it is a multiplexer-based circuit.
- the BR (Branch) field acts as the selector for this multiplexer, choosing from one of several sources for the next address.
- Typical sources, controlled by the BR field:
	1. Increment (Sequential Flow)
		- BR value: 00 (or similar, e.g., "SEQ")
		- Action: The next address is simply CAR + 1. (Control Address Register)
		- Use Case: This is the default for executing the next step in linear sequence of micro-operations
	2. Unconditional Branch (Jump)
		- BR Value: 01 (or "JUMP")
		- Action: The next address is taken directly from the AD (Address) field  of the current micro-instruction
		- Use Case: Jumping to the start of a completely different routine (e.g., jumping from the end of a Fetch cycle to the execute cycle for a specific instruction)
	3. Conditional Branch
		- BR Value: 10 (or "BRANCH")
		- Action: the NAG checks the condition specified by the CD (Condition Determinant) field (eg: "Is the Carry flag set?").
			- If the condition is TRUE, the next address is taken from the AD field.
			- If the condition is FALSE, the next address is CAR + 1.
		- Use Case: Implementing micro-level IF statements (e.g., "If the operand is zero, skip the multiplication step")
	4. Map Function (Opcode Mapping)
		- BR Value: 11 (or "MAP")
		- Action: The NAG takes the machine instruction's opcode from the instruction Register (IR), transforms it, and uses it as the next address. This is often a simple bit transformation.
			- example: if the opcode is 1011, the mapping might be 1 0110, which becomes the address for the "ADD" instruction's execute routine.
		- Use Case: This is the crucial step that happens at the end of the Fetch cycle. It uses the opcode to look up the starting address of the corresponding execute routine in the control store.
	5. Subroutine Call/Return
		- Call (BR = "CALL"): The return address (CAR + 1) is saved in a special Subroutine Return Register. The next address is taken from the AD field.
		- Return (BR = "RETURN"): The next address is taken from the Subroutine Return Register.
		- Use Case: For common sequences of micro-operations, like effective address calculation, to avoid duplicating code in the control store.
- **Example**: ADD R1, R2.
	- Fetch Cycle:
		- The CAR holds the address for the first micro-instruction of the Fetch cycle.
		- The micro-instructions here have BR=Increment, so the CAR just counts up through the step eg: PC -> MAR, Memory -> MBR, MBR -> IR.
		- The last micro-instruction in the Fetch cycle has BR = Map. The NAG takes the opcode from the IR (let's say 0001 for ADD), transforms it (e.g., to 1 0001), and loads this new address into the CAR.
	- Execute Cycle for ADD:
		- The CAR now points to the start of the ADD routine in the control store.
		- The micro-instructions here perform the addition.
			- R1 -> A (BR = increment)
			- R2 + A -> R1 (BR = Increment)
		- The last micro-instruction might check for overflow
			- (Check Overflow Flag) - CD=Overflow, BR=Conditional Branch, AD=Overflow_Error_Routine_Address.
			- If no overflow, the next address becomes the start of the Fetch cycle again
			  (BR=Unconditional, AD=Fetch_Start_Address).
- Summary
	- Address Sequencing: 
	  describes the problem and logic flow
	- Micro-instruction Format:
	  provides the control words that direct the Next Address Generator
	- The Next Address Generator:
	  *hardware implementation* that uses the micro-instruction fields and inputs like opcode to generate next address according to sequencing logic.
- Figure:
    ![Selection of address for control memory][selection_of_address.png]
# 3.5 Symbolic Micro-instructions
- Symbols are used in micro-instructions as in assembly language
- Simplest and most straightforward way to formulate an assembly language for a micro-program is 
	- to define symbols for each field of micro-instruction
	- and to give users the capability for defining their own symbolic addresses.
- A symbolic micro-program can be translated into binary equivalent by a micro-program assembler.
### 3.5.1 Sample Format
- Five fields: label; micro-ops; CR; BR; AD
	- Label field: may be empty or it may specify a symbolic address terminated with a colon
	- Micro-operations field: of one, two or three symbols separated by commas, the NOP symbol is used when the micro-instruction has no micro-operations.
	- CD field: one of the letters {U, I, S, Z} can be chosen where:
		- U: Unconditional Branch
		- I: Indirect address bit
		- S: Sign of AC
		- Z: Zero value in AC
	- BR field: contains one of the four symbols {JMP, CALL, RET, MAP}
	- AD field: specifies a value for the address field of the micro-instruction with one of {Symbolic address, NEXT, empty}
		- When the BR field contains a RET or MAP symbol, the AD field is left empty
# 3.6 Symbolic Microprogram
- Control Storage: 128 20-bit words
- The first 64 words: Routines for the 16 machine instructions. 0, 4, 8, ... 60 gives four words in control memory for each routine
- The last 64 words: Used for other purpose (e.g., fetch routine and other subroutines)
- The execution of the third (MAP) micro-instruction in the fetch routine results in a branch to address 0xxxx00, where xxxx are the four bits of the operation code. e.g., ADD is 0000.
- In each routine, we must provide micro-instructions for evaluating the EA and for executing the instruction.
- The indirect address mode is associated  with all memory-reference instructions.
- A saving in the number of control memory words may be achieved if the micro-instructions for the indirect address are stored as a subroutine.
- This subroutine, INDRCT, is located right after the fetch routine.
- Mapping: Opcode XXXX into 0XXXX00, the first address for the 16 routines are 0 (0 0000 00), 4 (0 0001 00), 8, 12, 16, 20, ... , 60.
### 3.6.1 Control Store Organisation
 - First 64 words (addresses 0-63): Execute routines for 16 instructions (4 microinstructions per instruction)
  - Remaining words (address 64+): Fetch routine and other utility routines
  - Convenient starting location for fetch routine: **address 64**
### 3.6.2 Fetch Subroutine
- During FETCH:
	1. Read an instruction from memory,
	2. decode the instruction
	3. update PC
	4. and transfer control to appropriate execute routine 
- The last 64 words maybe used for any other purpose.
	- A convenient starting location for the fetch routine is address 64.
- The three micro-instructions that constitute the fetch subroutine have been listed in three different representations.
	1. The register transfer representation:
		- AR  <- PC                                     ; Setup memory address
		- DR <- M[AR], PC <- PC + 1         ; Read instruction and increment PC
		- AR <- DR (0-10), CAR (2-5) <- DR (11-14), CAR (0,1,6) <- 0 ; Map opcode to execute routine
	2. The symbolic representation:
		- ORG 64                                       ; start fetch routine at address 64
		- PCTAR             U   JMP   NEXT  ; transfer PC to AR, jump to next address
		- READ, INCPC  U   JMP   NEXT  ; M[AR] -> DR, PC + 1 -> PC
		- NOP                 U   MAP              ; MAP DR (11-14) to execute routine address
	3. The binary representation:
			Binary Address       F1        F2      F3     CD          BR           AD
			1000000                 110      000   000     00          00      1000001
			1000001                 000     100     101      00          00      1000010
			1000010                 000     000    000     00          11       0000000
			- note for F1, F2, F3:
				1. 110 : PCTAR			
				2. 100: Read
				3. 101: INCPC
### 3.6.3 Addition (ADD) Execute Cycle
- During ADD Execute: ADD R2, R1
	1. Read source operand from register
	2. Read destination operand from register
	3. Perform addition operation
	4. Store result in destination register
	5. Check for overflow/conditions
	6. Return to fetch cycle
- There are 4 micro-instruction that constitute the ADD execute routine
- Assuming ADD execute routine starts at address 0 (first instruction).
- The four micro-instructions that constitute the fetch subroutine have been listed in three different representations.
	1. The register transfer representation
		- R1 <- R1                                           ; Read source operand (dummy read for timing)
		- AC <- R2                                         ; Read destination operand into Accumulator
		- AC <- AC + R1, Check overflow    ; Preform addition and check conditions
		- R2 <- AC, CAR <- 64                      ; Store result and return to fetch routine
	2. The symbolic representation
		- ORG 0                                            ; ADD routine starts at address 0  
		- NOP                       U  JMP  NEXT ; Read source operand (timing)
		- RTAC                     U  JMP  NEXT ; R2 -> AC (read destination)
		- ADD, CHECK OV  U  JMP  NEXT ; AC + R1 -> AC, check overflow
		- ACRT                    U  JMP  64      ; AC -> R2, return to fetch
	3. The binary representation
		- Assumed function codes:
			- RTAC          : Register to AC         : F1 = 010
			- ADRT          : AC to Register         : F1 = 011
			- ADD            : Addition                   : F2 = 010
			- CHECK OV : Overflow condition : CD = 01
		 Binary Address   F1     F2    F3   CD   BR         AD
		     0000000        000  000  000  00   00     0000001
		     0000001         010  000  000   00   00    0000010
		     0000010         000  010  000   01    00    0000011
		     0000011          011   000  000  00    00    1000000
	4. Explanation:
		1. First: Dummy read of source operand (R1) for pipeline timing
		2. Second: Load destination operand R2 into Accumulator
		3. Third: Peform addition and check overflow
		4. Fourth: Store result to destination register (AC -> R2) and return to fetch routine at address 64.
### 3.6.4 Binary Micro-program
- The symbolic micro-program must be translated to binary either by means of assembler program or by the user if the micro-program is simple.
### 3.6.5 Control Memory
- When a ROM is used for the control memory, the micro-program binary list provides the truth table for fabricating the unit
	- To modify the instruction set of the computer, it is necessary to generate a new micro-program and mask a new ROM.
- adv of employing a RAM for control memory is that the micro-program can be altered simply by writing a new pattern of 1's and 0's without resorting to hardware procedure.
- However, most micro-program systems use a ROM for control memory because its cheap and faster than RAM.

1. Write a microprogram for the fetch cycle and addition cycle. [5] (81 Bh)
2. Write down the symbolic microprogram for fetch routine and addition execute routine. [4] (78 Ka)
3. Write micro program for fetch cycle. [4] (73 Shr)
4. Differentiate between symbolic and binary micro instruction. [4] (81 Ba)
# 3.7 Control Unit Operation
- A computer executes a program consisting of instructions, which are made up of shorter sub-cycles as fetch, indirect, execute, interrupt cycles.
- these sub-cycles are called:
	1. micro-operations because they are very simple and do very little tasks, and also called functional.
	2. functional atomic operation of CPU.
- Hence events of any instruction cycle can be described as a sequence of micro-operations
- Figure for Program Execution:
  ![Constituent Elements of Program Execution][control_unit_operations.png]

## 3.7.1 Types of Micro-operation
- Transfer data between registers
- Transfer data from register to external interface
- Transfer data from external interface to register
- Perform arithmetic/logical ops with register for i/o.
## 3.7.2 Functions of CU
- Sequencing
- Causing the CPU to step through a series of micro-operations
- Execution
- Causing the performance of each micro-operation.
## 3.7.3 Control Signals
- CU behaves so, due to its Control Signals.
- Layout of Control Unit and signals:
  ![Control Unit and Signals | 600][control_signals.png]
### 3.7.3a Inputs to Control Unit:
1. Clock
	- CU causes one micro-instruction (or set of parallel micro-instructions) per clock cycle
2. Instruction Register
	- Opcode for current instruction determines which micro-instructions are performed.
3. Flags
	- State of CPU
	- Results of previous operations
4. Interrupt (from control bus)
	- Interrupts
	- Acknowledgements
### 3.7.3b Outputs (Control Signals)
1. Within CPU (2 types)
	- Cause data movement
	- Activate specific ALU functions
2. Via control bus (2 types)
	- To memory
	- To I/O modules
3. Types of Control Signals
	- Those that activate an ALU
	- Those that activate a data path
	- Those that are signal on external interface

All these are applied as binary input to individual logic gates.
## 3.7.4 Implementations
### 3.7.4a Hardwired Implementation
- In this implementation, CU is essentially a combinational circuit. Its i/p signals are transformed into set of o/p logic signal which are control signals.
- Control unit inputs
- Flags and control bus: each bit means something
- Instruction register
	- Opcode causes different control signals for each different instruction
	- Unique logic for each opcode
	- Decoder takes encoded input and produces single output
	- Each decoder i/p will activate a single unique o/p
- Clock
	- Repetitive sequence of pulses
	- Useful for measuring duration of micro-operations
	- Must be long enough to allow signal propagation along data paths and through process circuitry
	- Different control signals at different times within instruction cycle
	- Need a counter as i/p to control unit with different control signals being used for t1, t2, etc.
	- At the end of instruction cycle, counter is re-initialised.
- Control unit with decoded input figure:
  ![Control Unit with Decoded Input | 500][hardwired_implementation.png]

**Implementation**
- For each control signal, a Boolean expression of that signal as a function of the inputs is derived.
- With that the combinational circuit is realised as control unit.
**Problems with Hardwired Designs**
- Complex sequencing & micro-operation logic
- Difficult to design and test
- Inflexible design
- Difficult to add new instructions
#### 3.7.4b Micro-programmed Implementation
- An alternative to hardwired CU
- Common in contemporary CISC processors
- Use sequences of instructions to perform control operations performed by micro operations called micro-programming or firmware.
- Figure:
  ![Microprogrammed CU | 550][microprogrammed_cu.png]
**Implementation**
- Set of micro-instructions are stored in control memory
- Control address register contains the address of the next micro-instruction to be read
- As it is read, it is transferred to control buffer register
- For horizontal micro-instructions, reading a micro-instruction is same as executing it.
- Sequencing unit loads the control address register and issues a read command.
**Functionality**
- Sequencing logic issues read command to control memory
- Word whose address is in control address register is read into control buffer register.
- Content of control buffer register generates control signals and next address instruction for the sequencing logic unit.
- Sequencing logic unit loads new address into control address register depending on the values of ALU flags, control buffer register.
- One of following decision is made:
	- add 1 to control address register
	- load address from address field of control buffer register
	- load the control address register based on opcode in IR
- Upper decoder translates the opcode of IR into control memory address.
- Lower decoder used for vertical micro instructions.
#### 3.7.4c Difference
| Parameters                            | CISC                                                                                   | CISC                                                                    |
| ------------------------------------- | -------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| Speed                                 | fast                                                                                   | slow                                                                    |
| Cost of Implementation                | more costly                                                                            | cheaper                                                                 |
| Flexibility                           | not flexible to accommodate new system specification/instruction. Redesign is required | more flexible to accommodate new system specification/instruction sets. |
| Ability to handle complex instruction | difficult to handle                                                                    | easier to handle                                                        |
| Decoding                              | complex decoding and sequencing logic                                                  | easier decoding and sequencing logic                                    |
| Applications                          | RISC Microprocessor                                                                    | CISC Microprocessor                                                     |
| Instruction set size                  | Small                                                                                  | Large                                                                   |
| Control Memory                        | Absent                                                                                 | Present                                                                 |
| Chip Area required                    | less                                                                                   | More                                                                    |
| Occurence                             | Occurrence of error is more                                                            | occurrence of error is less                                             |
# 3.8 Design of Control Unit
## 3.8.1 Micro-instruction bit fields
- The bits of the micro-instruction are usually divided into fields.
- each field have their own distinct/separate function
- they provide:
	- control bits to initiate micro-operations in the system
	- special bits to specify the way that the next address is to be evaluated
	- an address field for branching
- the number of control bits that initiate micro-operations can be reduced by grouping mutually exclusive variables into fields by encoding the k bits in each field to provide 2$^k$ micro-operations.
- Each field requires a decoder to produce the corresponding control signals
	- Reduces the size of the micro-instruction bits
	- Requires additional hardware external to the control memory
	- Increases the delay time of the control signals.

- Referring to the figure, we discuss as: 
  ![Decoding of Micro-operation fields][decoder.png]
- Figure shows 3 decoders and some of the connections that must be made from their outputs
- Outputs 5 OR 6 (5 | 6) of decoder F1 are connected to the load input of AR so that
	- when either one of these outputs is active;
		- information from the multiplexers is transferred to AR.
- The transfer into AR occurs with a clock pulse transition 
	- only when output 5 (from DR (0-10) to AR i.e. DRTAR)
	- or output 6 (from PC to AR i.e. PCTAR) of the decoder are active.
- Instead of using gates to generate the control signals,
	- the arithmetic logic shift unit can be designed from the output of decoders.
### 3.8.2 Micro-program sequencer
- the basic components of a micro-programmed control unit are the control memory and the circuits that select the next address.
- The address selection part is called a micro-program sequencer
- a micro-program seqencer can be constructed with digital functions to suit a particular application.
- to guarantee a wide range of acceptability, an integrated circuit sequencer must provide an internal organisation that can be adapted to a wide range of application.
- The purpose of a micro-program sequencer is to present an address to the control memory so that a micro-instruction may be read and executed.
- From the figure, we discuss as:
  ![Microprogram Sequencer for a Control Memory][microprogram.png]
	- The control memory is included to show to interaction between the sequencer and the attached components.
	- There are two multiplexers in the ckt
		- 1st: selects an address from 1 of 4 sources and route to CAR
		- 2nd: tests the value of selected bit status bit and result is applied to an input logic circuit.
	- The output from CAR provides the address for control memory, contents of CAR incremented and applied to one of the multiplexers input and to the SBR.
	- Although the diagram shows a single subroutine register (SBR), a typical sequencer will have a register stack about four to eight levels deep.
	- In this way, a push pop operation and stack pointer operates for subroutine call and return instructions.
	- The Condition field (CD) of the micro-instruction selects one of the status bits in the second multiplexer.
	- The Test variable (either 1 or 0) i.e. T value together with the two bits from the Branch field (BR) field go to an input logic ckt
	- The input logic ckt determines the type of operation.